--1
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local mt = getrawmetatable(game)
setreadonly(mt, false)
local oldNamecall = mt.__namecall
local macro = {}
local isRecording = false
local isPlaybacking = false
local recordingStartTime

local macroManager = {}
local currentMacroName

local playbackThread = nil
local isPlayingLoopRunning = false

local isRecordingLoopRunning = false
local recordingThread = nil

local HttpService = game:GetService("HttpService")
local ShowGameEnd = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("ShowGameEnd")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")

local State = {
    AutoSelectDifficultyEnabled = false,
    SelectedDifficultyValue = {},
    AutoSelectSpeed = false,
    SelectedSpeedValue = {},
    AutoRetryEnabled = false,
    hasSentWebhook = false,
    SendStageCompletedWebhook = false,
    StageStartTime = 0,
    autoplayEnabled = false,
}

local autoplayActive = false
local placedUnits = {} -- Store placed unit data: {id = unitData, position = Vector3, etc}
local placementConnection = nil
local upgradeConnection = nil

local placementSettings = {
    placementDelay = 1, -- Seconds between placements
    upgradeDelay = 0.5, -- Seconds between upgrades
    maxPlacementAttempts = 10, -- Max attempts to find valid placement spot
    placementSpacing = 4, -- Minimum distance between units
    lastPlacement = 0,
    lastUpgrade = 0,
    lastStatusUpdate = 0,
    lastPositionWarning = 0,
}

local config = {
    toggleKey = Enum.KeyCode.G, -- Key to toggle rectangle
    width = 20, -- Width (X axis)
    length = 15, -- Length (Z axis) 
    height = 0.5, -- How thick the rectangle is
    offsetFromSpawn = Vector3.new(0, 0, -10), -- X, Y, Z offset from spawn point
    transparency = 0.3, -- 0 = opaque, 1 = fully transparent
    color = Color3.fromRGB(0, 255, 0), -- Green color
    material = Enum.Material.ForceField, -- Material for the rectangle
    canCollide = false, -- Whether players can walk through it
    raycastDistance = 1000 -- How far down to raycast
}

local spawnCaps = {
    tower1 = 5,
    tower2 = 5,
    tower3 = 5,
    tower4 = 5,
    tower5 = 5,
    tower6 = 5,
}

-- Move this section up, right after all your function definitions

local rectangle = nil
local rectangleEnabled = false
local ValidWebhook

local playbackMode = "timing" -- Default mode: "timing", "wave", "both"
local currentWave = 0
local waveStartTime = 0

local unitDataCache = {}

local unitConfigCache = {}
local placedUnitsTracking = {} -- Track units we place and their upgrade levels
local cashHandlingMode = "wait" -- "wait", "skip", "force"

local function getTableKeys(tbl)
    local keys = {}
    for k in pairs(tbl) do
        table.insert(keys, k)
    end
    return keys
end

local function getAllSpawnCaps()
    return spawnCaps
end

local function getPlayerCash()
    return LocalPlayer:GetAttribute("Cash") or 0
end

local function canAffordUnit(unitData)
    local playerCash = getPlayerCash()
    return playerCash >= unitData.cost
end

local function extractUnitName(itemID)
    print("DEBUG - extractUnitName input:", itemID, "type:", type(itemID))
    
    if not itemID or type(itemID) ~= "string" then
        warn("extractUnitName: Invalid itemID -", tostring(itemID))
        return nil
    end
    
    local unitName = itemID:gsub("^tl_unitplacer_", "")
    print("DEBUG - extractUnitName output:", unitName)
    return unitName
end

local function getUnitConfig(unitName)
    if not unitName then
        return nil
    end
    
    -- Return cached config if available
    if unitConfigCache[unitName] then
        return unitConfigCache[unitName]
    end
    
    -- Try to get config from game
    local success, config = pcall(function()
        local configPath = LocalPlayer.PlayerGui.LogicHolder.ClientLoader.SharedConfig.ItemData.Units.Configs
        local unitModule = configPath:FindFirstChild(unitName)
        
        if unitModule and unitModule:IsA("ModuleScript") then
            return require(unitModule)
        end
        return nil
    end)
    
    if success and config then
        -- Cache the config for future use
        unitConfigCache[unitName] = config
        print(string.format("üìã Loaded config for %s - Cost: %d, Max Level: %d", 
            unitName, config.UnitConfig.Cost or 0, #(config.UnitConfig.Upgrades or {})))
        return config
    else
        warn("‚ùå Could not load unit config for:", unitName)
        return nil
    end
end

local function getAvailableUnits()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then
        warn("Player backpack not found")
        return {}, {}
    end
    
    local units = {}
    local towerMapping = {}

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local itemID = tool:GetAttribute("ItemID")
            local serverIdentifier = tool:GetAttribute("ServerIdentifier")
            
            print("DEBUG - Processing tool:", tool.Name)
            print("  ItemID:", itemID)
            print("  ServerIdentifier:", serverIdentifier)
            
            if itemID and itemID:match("^tl_unitplacer_") and serverIdentifier then
                local unitName = extractUnitName(itemID)
                local config = getUnitConfig(unitName)
                
                if config and config.UnitConfig then
                    local unitData = {
                        name = unitName,
                        displayName = config.Name or config.DisplayName or unitName, -- Try multiple name fields
                        tool = tool,
                        itemID = itemID, -- Make sure this is preserved
                        image = config.Image,
                        rarity = config.Rarity,
                        unitType = config.UnitType,
                        placeable = config.Placeable,
                        config = config.UnitConfig,
                        cost = config.UnitConfig.Cost or 0,
                        range = config.UnitConfig.Range or 0,
                        damage = config.UnitConfig.Damage or 0,
                        apm = config.UnitConfig.APM or 0,
                        upgrades = config.UnitConfig.Upgrades or {},
                        serverIdentifier = serverIdentifier
                    }
                    
                    print("DEBUG - Created unit data for:", unitName)
                    print("  displayName:", unitData.displayName)
                    print("  itemID:", unitData.itemID)
                    
                    table.insert(units, unitData)
                    towerMapping["tower" .. serverIdentifier] = unitName
                end
            end
        end
    end
    
    print("DEBUG - Final units count:", #units)
    print("DEBUG - Tower mapping:", HttpService:JSONEncode(towerMapping))
    
    return units, towerMapping
end

local function getBestAffordableUnits()
    local availableUnits = getAvailableUnits()
    local playerCash = getPlayerCash()
    local affordableUnits = {}
    
    for _, unit in pairs(availableUnits) do
        if unit.cost > 0 and unit.cost <= playerCash then
            -- Calculate value score (damage * apm / cost) with nil safety
            local damage = unit.damage or 0
            local apm = unit.apm or 0
            local cost = unit.cost or 1 -- Avoid division by zero
            
            local valueScore = 0
            if cost > 0 and damage > 0 and apm > 0 then
                valueScore = (damage * apm) / cost
            end
            
            unit.valueScore = valueScore
            table.insert(affordableUnits, unit)
        end
    end
    
    -- Sort by value score (highest first)
    table.sort(affordableUnits, function(a, b)
        return a.valueScore > b.valueScore
    end)
    
    return affordableUnits
end

local function getUnitPlacementCost(unitName)
    local config = getUnitConfig(unitName)
    if config and config.UnitConfig then
        return config.UnitConfig.Cost or 0
    end
    return 0
end

local function getUpgradeCost(unitName, upgradeLevel)
    local config = getUnitConfig(unitName)
    if not config or not config.UnitConfig or not config.UnitConfig.Upgrades then
        return 0
    end
    
    local upgrades = config.UnitConfig.Upgrades
    if upgradeLevel >= 1 and upgradeLevel <= #upgrades then
        return upgrades[upgradeLevel].Cost or 0
    end
    
    return 0
end

local function trackPlacedUnit(position, unitName)
    local posKey = tostring(position)
    placedUnitsTracking[posKey] = {
        unitName = unitName,
        currentLevel = 0, -- Start at base level (0 upgrades)
        position = position,
        placedTime = tick()
    }
    print(string.format("üìç Tracking unit: %s at %s (Level 0)", unitName, posKey))
end

local function trackUnitUpgrade(position)
    local posKey = tostring(position)
    if placedUnitsTracking[posKey] then
        placedUnitsTracking[posKey].currentLevel = placedUnitsTracking[posKey].currentLevel + 1
        local newLevel = placedUnitsTracking[posKey].currentLevel
        print(string.format("‚¨ÜÔ∏è Unit at %s upgraded to level %d", posKey, newLevel))
        return newLevel
    else
        -- We don't know this unit, assume it's now level 1
        print(string.format("‚ö†Ô∏è Unknown unit upgraded at %s (assuming level 1)", posKey))
        return 1
    end
end

local function canAffordUnitPlacement(unitName)
    local cost = getUnitPlacementCost(unitName)
    local cash = getPlayerCash()
    local canAfford = cash >= cost
    
    print(string.format("üí∞ Unit placement check - %s: Cost %d, Cash %d, Can afford: %s", 
        unitName, cost, cash, tostring(canAfford)))
    
    return canAfford, cost, cash
end

local function canAffordUnitUpgrade(position, unitName)
    local posKey = tostring(position)
    local unitData = placedUnitsTracking[posKey]
    local cash = getPlayerCash()
    
    if unitData then
        -- We know this unit's current level
        local nextLevel = unitData.currentLevel + 1
        local cost = getUpgradeCost(unitData.unitName, nextLevel)
        local canAfford = cash >= cost
        
        print(string.format("üí∞ Upgrade check - %s Level %d‚Üí%d: Cost %d, Cash %d, Can afford: %s", 
            unitData.unitName, unitData.currentLevel, nextLevel, cost, cash, tostring(canAfford)))
        
        return canAfford, cost, cash, nextLevel
    else
        -- We don't know this unit's level, assume it needs level 1 upgrade
        local cost = getUpgradeCost(unitName or "unknown", 1)
        local canAfford = cash >= cost
        
        print(string.format("‚ö†Ô∏è Unknown unit upgrade check at %s: Assuming level 1 upgrade, Cost %d, Cash %d", 
            posKey, cost, cash))
        
        return canAfford, cost, cash, 1
    end
end

local function setCashHandlingMode(mode)
    if mode == "wait" or mode == "skip" or mode == "force" then
        cashHandlingMode = mode
        print(string.format("üí∞ Cash handling mode set to: %s", mode))
    else
        warn("‚ùå Invalid cash handling mode:", mode)
    end
end

local function getCashHandlingMode()
    return cashHandlingMode
end

local function getCurrentWave()
    return workspace:GetAttribute("Round") or 0
end

local function onWaveChanged()
    local newWave = getCurrentWave()
    if newWave ~= currentWave then
        currentWave = newWave
        waveStartTime = tick()
        print(string.format("üåä Wave %d started at %.2fs", currentWave, waveStartTime))
    end
end

local function tryPlaceUnit(unitName, args, maxRetries)
    maxRetries = maxRetries or 5 -- Increased default retries
    local baseRetryDelay = 0.5 -- Base delay between retries
    local positionOffset = 2 -- Maximum studs to offset position
    local originalPosition = args.Position

    local function isMatchingModel(model)
        return model:IsA("Model")
            and model.Name == unitName
            and (model.WorldPivot.Position - args.Position).Magnitude < 5 -- Slightly larger tolerance for offset positions
            and model:GetAttribute("ID") ~= nil
    end

    local function generateOffsetPosition(attempt)
        if attempt == 1 then
            return originalPosition -- First attempt uses original position
        end
        
        -- Generate random offset for subsequent attempts
        local offsetX = (math.random() - 0.5) * positionOffset * 2 -- -positionOffset to +positionOffset
        local offsetZ = (math.random() - 0.5) * positionOffset * 2
        
        return Vector3.new(
            originalPosition.X + offsetX,
            originalPosition.Y,
            originalPosition.Z + offsetZ
        )

        end

    for attempt = 1, maxRetries do
        print(string.format("üîÑ Attempting to place %s (attempt %d/%d)", unitName, attempt, maxRetries))
        
        -- Generate position for this attempt
        local attemptPosition = generateOffsetPosition(attempt)
        args.Position = attemptPosition
        args.CF = CFrame.new(attemptPosition, attemptPosition + Vector3.new(0, 0, 1)) -- Update CF to match new position
        
        -- Snapshot current unit models before placement
        local beforeModels = {}
        for _, model in ipairs(workspace.Map.Entities:GetChildren()) do
            if isMatchingModel(model) then
                beforeModels[model] = true
            end
        end

        -- Try to place with current position
        local success, err = pcall(function()
            game.ReplicatedStorage.RemoteFunctions.PlaceUnit:InvokeServer(unitName, args)
        end)

        -- Wait a bit longer for placement to register
        task.wait(0.3)

        -- Look for new matching model
        for _, model in ipairs(workspace.Map.Entities:GetChildren()) do
            if isMatchingModel(model) and not beforeModels[model] then
                print(string.format("‚úÖ Unit %s placed successfully on attempt %d at position %s", 
                    unitName, attempt, tostring(attemptPosition)))
                return true
            end
        end

        -- If we failed and this isn't the last attempt, wait before retrying
        if attempt < maxRetries then
            local retryDelay = baseRetryDelay * attempt -- Increase delay with each attempt
            print(string.format("‚ö†Ô∏è Placement failed on attempt %d for %s%s. Waiting %.1fs before retry...", 
                attempt, unitName, err and (" - " .. tostring(err)) or "", retryDelay))
            task.wait(retryDelay)
        else
            warn(string.format("‚ùå Failed to place %s after %d attempts. Skipping unit placement.", 
                unitName, maxRetries))
        end
    end

    -- Restore original position in args (in case it's used elsewhere)
    args.Position = originalPosition
    args.CF = CFrame.new(originalPosition, originalPosition + Vector3.new(0, 0, 1))
    
    return false
end

local function FindUnitId(targetPos)
    local entities = workspace:WaitForChild("Map"):WaitForChild("Entities")
    local closestUnit = nil
    local closestDistance = math.huge
    local tolerance = 5 -- Increased tolerance for position matching

    for _, model in ipairs(entities:GetChildren()) do
        if model:IsA("Model") then
            local modelPos = model.WorldPivot.Position
            local distance = (modelPos - targetPos).Magnitude
            
            if distance < tolerance and distance < closestDistance then
                local id = model:GetAttribute("ID")
                if id then
                    closestDistance = distance
                    closestUnit = id
                end
            end
        end
    end

    if closestUnit then
        print(string.format("üéØ Found unit %s at distance %.2f from target", closestUnit, closestDistance))
    else
        warn("‚ùå No unit found within tolerance at position:", targetPos)
    end

    return closestUnit
end

local function executeActionWithCashCheck(action)
    if action.action == "PlaceUnit" then
        local canAfford, cost, cash = canAffordUnitPlacement(action.unitName)
        
        if not canAfford then
            if cashHandlingMode == "wait" then
                print(string.format("üí∏ Waiting for cash - Need %d more for %s", 
                    cost - cash, action.unitName))
                return "wait" -- Signal to wait and try again
            elseif cashHandlingMode == "skip" then
                print(string.format("‚è≠Ô∏è Skipping %s placement - insufficient cash", action.unitName))
                return "skip" -- Skip this action
            elseif cashHandlingMode == "force" then
                print(string.format("üö´ Force mode - attempting %s placement anyway", action.unitName))
                -- Continue with placement attempt
            end
        end
        
        -- Attempt placement
        local success = tryPlaceUnit(action.unitName, {
            Valid = action.valid,
            Rotation = action.rotation,
            CF = action.cframe,
            Position = action.position
        }, 5)
        
        if success then
            trackPlacedUnit(action.position, action.unitName)
            return "success"
        else
            return "failed"
        end
        
    elseif action.action == "UpgradeUnit" then
        local canAfford, cost, cash, nextLevel = canAffordUnitUpgrade(action.position, nil)
        
        if not canAfford then
            if cashHandlingMode == "wait" then
                print(string.format("üí∏ Waiting for upgrade cash - Need %d more", cost - cash))
                return "wait"
            elseif cashHandlingMode == "skip" then
                print(string.format("‚è≠Ô∏è Skipping upgrade - insufficient cash"))
                return "skip"
            elseif cashHandlingMode == "force" then
                print("üö´ Force mode - attempting upgrade anyway")
            end
        end
        
        -- Attempt upgrade
        local id = FindUnitId(action.position)
        if id then
            local success, err = pcall(function()
                game.ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(id)
            end)
            if success then
                trackUnitUpgrade(action.position)
                return "success"
            else
                warn("‚ùå Failed to upgrade unit:", id, err)
                return "failed"
            end
        else
            warn("‚ö†Ô∏è Could not find unit to upgrade at position:", action.position)
            return "failed"
        end
        
    elseif action.action == "SellUnit" then
        -- Selling doesn't require cash checking
        local id = FindUnitId(action.position)
        if id then
            local success, err = pcall(function()
                game.ReplicatedStorage.RemoteFunctions.SellUnit:InvokeServer(id)
            end)
            if success then
                -- Remove from tracking
                placedUnitsTracking[tostring(action.position)] = nil
                print("üí∞ Sold unit:", id)
                return "success"
            else
                warn("‚ùå Failed to sell unit:", id, err)
                return "failed"
            end
        else
            warn("‚ö†Ô∏è Could not find unit to sell")
            return "failed"
        end
        
    elseif action.action == "SkipWave" then
        local success, err = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SkipWave"):InvokeServer("y")
        end)
        return success and "success" or "failed"
    end
    
    return "unknown"
end

local function shouldExecuteAction(action, currentTime, currentWave, currentWaveTime)
    if playbackMode == "timing" then
        -- Original timing-based execution
        return currentTime >= action.time
        
    elseif playbackMode == "wave" then
        -- Wave-based execution (ignore original timing, use wave progression)
        if currentWave > action.wave then
            return true -- Execute if we're past the recorded wave
        elseif currentWave == action.wave then
            return currentWaveTime >= (action.waveTime or 0) -- Execute if we're at the right time in the current wave
        end
        return false
        
    elseif playbackMode == "both" then
        -- Hybrid mode: require both timing AND wave conditions
        local timingReady = currentTime >= action.time
        local waveReady = currentWave >= action.wave and 
                         (currentWave > action.wave or currentWaveTime >= (action.waveTime or 0))
        return timingReady and waveReady
    end
    
    return false
end

local function getCurrentUnitCount()
    return LocalPlayer:GetAttribute("UnitsPlaced") or 0
end

local function getMaxUnitCount()
    return LocalPlayer:GetAttribute("MaxUnitsPlaced") or 0
end

local function canPlaceMoreUnits()
    local current = getCurrentUnitCount()
    local max = getMaxUnitCount()
    return current < max
end


local function getAutoplayZone()
    return workspace:FindFirstChild("AutoplayZone")
end

local function getRandomPlacementPosition()
    local autoplayZone = getAutoplayZone()
    if not autoplayZone then
        warn("Autoplay zone not found! Enable the green rectangle first.")
        return nil
    end
    
    local size = autoplayZone.Size
    local position = autoplayZone.Position
    
    -- Generate random position within the rectangle bounds
    local randomX = position.X + (math.random() - 0.5) * (size.X - 2) -- -2 for padding
    local randomZ = position.Z + (math.random() - 0.5) * (size.Z - 2)
    
    -- Use the autoplay zone Y position (it's already on the ground)
    local randomY = position.Y + (size.Y / 2) + 1 -- Slightly above the zone
    
    return Vector3.new(randomX, randomY, randomZ)
end

local function isPositionTooClose(newPosition)
    for _, unitData in pairs(placedUnits) do
        if unitData.position then
            local distance = (newPosition - unitData.position).Magnitude
            if distance < placementSettings.placementSpacing then
                return true
            end
        end
    end
    return false
end

local function findValidPlacementPosition()
    for attempt = 1, placementSettings.maxPlacementAttempts do
        local position = getRandomPlacementPosition()
        if position and not isPositionTooClose(position) then
            return position
        end
    end
    return nil
end

local function validateUnitExists(unitId)
    -- Check if unit actually exists in game world
    local entities = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Entities")
    if not entities then
        return false
    end
    
    for _, model in pairs(entities:GetChildren()) do
        if model:IsA("Model") and model:GetAttribute("ID") == unitId then
            return true
        end
    end
    
    return false
end

local function cleanupInvalidUnits()
    -- Remove units from our tracking that no longer exist in game
    local validUnits = {}
    for unitId, unitData in pairs(placedUnits) do
        if validateUnitExists(unitId) then
            validUnits[unitId] = unitData
        else
            print("Removed invalid unit from tracking:", unitId)
        end
    end
    placedUnits = validUnits
end

local function getPlacedUnitCountsBySlot(towerMapping)
    local counts = {}
    for i = 1, 6 do
        counts["tower" .. i] = 0
    end
    
    local entities = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Entities")
    if not entities then
        return counts
    end
    
    for _, model in ipairs(entities:GetChildren()) do
        if model:IsA("Model") then
            local unitName = model.Name -- Assuming model name matches unitName (e.g., "unit_farmer_npc")
            for towerSlot, mappedUnit in pairs(towerMapping) do
                if unitName == mappedUnit then
                    counts[towerSlot] = (counts[towerSlot] or 0) + 1
                end
            end
        end
    end
    
    return counts
end

local function getNextUnitToPlace()
    if not canPlaceMoreUnits() then
        print("Cannot place more units - global limit reached")
        return nil
    end

    local availableUnits, towerMapping = getAvailableUnits()
    local spawnCaps = getAllSpawnCaps()
    local placedCounts = getPlacedUnitCountsBySlot(towerMapping)
    
    -- Debug logging
    --print("=== PLACEMENT DEBUG ===")
   -- print("Available units count:", #availableUnits)
   -- print("Tower mapping:", HttpService:JSONEncode(towerMapping))
   -- print("Spawn caps:", HttpService:JSONEncode(spawnCaps))
    --print("Placed counts:", HttpService:JSONEncode(placedCounts))

    -- Try each tower slot in order
    for i = 1, 6 do
        local towerSlot = "tower" .. i
        local spawnCap = spawnCaps[towerSlot] or 0
        local placedCount = placedCounts[towerSlot] or 0
        
        --print(string.format("Checking %s: Cap=%d, Placed=%d", towerSlot, spawnCap, placedCount))

        if spawnCap > 0 and placedCount < spawnCap then
            -- Find the unit that corresponds to this tower slot
            local unitName = towerMapping[towerSlot]
            if unitName then
                -- Find the actual unit data for this unit name
                local targetUnit = nil
                for _, unit in pairs(availableUnits) do
                    if unit.name == unitName then
                        targetUnit = unit
                        break
                    end
                end
                
                if targetUnit and canAffordUnit(targetUnit) then
                    --print("Found affordable unit:", targetUnit.displayName or targetUnit.name, "for", towerSlot)
                    return {
                        unit = targetUnit,
                        towerSlot = towerSlot,
                        priority = i
                    }
                else
                   -- print("Unit", unitName, "not affordable or not found for", towerSlot)
                end
            else
                print("No unit mapped to", towerSlot)
            end
        else
            print(towerSlot, "is at or exceeded cap")
        end
    end

    --print("No valid unit to place found")
    return nil
end

local function placeUnit(unitToPlace, position)
    if not canPlaceMoreUnits() then
        warn("Cannot place unit - max unit limit reached")
        return false
    end

    local unitName = extractUnitName(unitToPlace.unit.itemID)
    if not unitName then
        warn("Could not extract unit name from ItemID:", unitToPlace.unit.itemID)
        return false
    end

    local args = {
        unitName,
        {
            Valid = true,
            Rotation = math.random(0, 360),
            CF = CFrame.new(position, position + Vector3.new(0, 0, 1)),
            Position = position
        }
    }

    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceUnit"):InvokeServer(unpack(args))
    end)

    if success and result then
        local unitData = {
            id = result,
            unit = unitToPlace.unit,
            position = position,
            towerSlot = unitToPlace.towerSlot,
            priority = unitToPlace.priority,
            upgradeLevel = 0,
            placedTime = tick()
        }
        placedUnits[result] = unitData

        -- IMPORTANT: Also track in placedUnitsTracking for upgrade system
        trackPlacedUnit(position, unitToPlace.unit.name)

        print(string.format("‚úì Placed %s (ID: %s) at %s - %s [%d/%d total units]", 
            unitToPlace.unit.displayName or unitToPlace.unit.name, 
            tostring(result), 
            tostring(position), 
            unitToPlace.towerSlot,
            getCurrentUnitCount(),
            getMaxUnitCount()))
        return true
    else
        warn("Failed to place unit:", unitToPlace.unit.displayName or unitToPlace.unit.name, result)
        return false
    end
end

local function getUnitsToUpgrade()
    cleanupInvalidUnits()
    
    local unitsToUpgrade = {}
    local playerCash = getPlayerCash()
    
    print("DEBUG - Checking upgrades. Player cash:", playerCash)
    print("DEBUG - Placed units count:", #placedUnits)
    
    for id, unitData in pairs(placedUnits) do
        print("DEBUG - Checking unit ID:", id, "Name:", unitData.unit.name)
        
        if validateUnitExists(id) then
            local unit = unitData.unit
            local currentLevel = unitData.upgradeLevel or 0
            local maxLevel = #(unit.upgrades or {})
            
            print("DEBUG - Unit", unit.name, "current level:", currentLevel, "max level:", maxLevel)
            
            if currentLevel < maxLevel then
                local nextLevel = currentLevel + 1
                local upgradeCost = getUpgradeCost(unit.name, nextLevel) -- Fix: use unit.name
                
                print("DEBUG - Next level:", nextLevel, "cost:", upgradeCost)
                
                if upgradeCost > 0 and playerCash >= upgradeCost then
                    table.insert(unitsToUpgrade, {
                        id = id,
                        unitData = unitData,
                        upgradeCost = upgradeCost,
                        currentLevel = currentLevel,
                        nextLevel = nextLevel,
                        priority = unitData.priority or 999
                    })
                    print("DEBUG - Added unit to upgrade queue:", unit.name)
                else
                    print("DEBUG - Cannot afford upgrade or cost is 0. Cost:", upgradeCost, "Cash:", playerCash)
                end
            else
                print("DEBUG - Unit already at max level")
            end
        else
            print("DEBUG - Unit no longer exists:", id)
        end
    end
    
    -- Sort by priority
    table.sort(unitsToUpgrade, function(a, b)
        if a.priority == b.priority then
            return a.upgradeCost < b.upgradeCost
        end
        return a.priority < b.priority
    end)
    
    print("DEBUG - Found", #unitsToUpgrade, "units ready for upgrade")
    return unitsToUpgrade
end

local function upgradeUnit(unitToUpgrade)
    local id = unitToUpgrade.id
    local unitData = unitToUpgrade.unitData
    
    print("DEBUG - Attempting to upgrade unit:", id, unitData.unit.name)
    
    -- Validate unit exists and cash is sufficient before upgrade
    if not validateUnitExists(id) then
        warn("Cannot upgrade unit - unit no longer exists:", id)
        placedUnits[id] = nil
        return false
    end
    
    local playerCash = getPlayerCash()
    print("DEBUG - Player cash:", playerCash, "Upgrade cost:", unitToUpgrade.upgradeCost)
    
    if playerCash < unitToUpgrade.upgradeCost then
        print("DEBUG - Not enough cash for upgrade")
        return false
    end
    
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("UpgradeUnit"):InvokeServer(id)
    end)
    
    print("DEBUG - Upgrade remote call result:", success, result)
    
    if success and result then
        local oldLevel = placedUnits[id].upgradeLevel or 0
        placedUnits[id].upgradeLevel = oldLevel + 1
        
        -- Also update the tracking system
        trackUnitUpgrade(unitData.position)
        
        print(string.format("‚¨Ü Upgraded %s (ID: %s) to level %d (Cost: %d)", 
            unitData.unit.displayName or unitData.unit.name,
            tostring(id),
            placedUnits[id].upgradeLevel,
            unitToUpgrade.upgradeCost))
        
        return true
    else
        warn("Failed to upgrade unit:", id, result)
        return false
    end
end

local function autoplayPlacementLoop()
    if not autoplayActive then return end

    local currentTime = tick()
    if currentTime - placementSettings.lastPlacement < placementSettings.placementDelay then
        return
    end

    cleanupInvalidUnits()
    local unitToPlace = getNextUnitToPlace()
    if not unitToPlace then
        if currentTime - (placementSettings.lastStatusUpdate or 0) > 10 then
            local current = getCurrentUnitCount()
            local max = getMaxUnitCount()
            local _, towerMapping = getAvailableUnits()
            local placedCounts = getPlacedUnitCountsBySlot(towerMapping)
            local spawnCaps = getAllSpawnCaps()

            print(string.format("üìä Autoplay Status: %d/%d total units placed", current, max))
            for slot, cap in pairs(spawnCaps) do
                local placed = placedCounts[slot] or 0
                print(string.format("  %s (%s): %d/%d", slot, towerMapping[slot] or "unknown", placed, cap))
            end

            if current >= max then
                print("üõë Max unit limit reached!")
            elseif allCapsFull then
                print("üõë All spawn caps reached!")
            else
                print("üí∞ Waiting for cash or better units...")
            end

            placementSettings.lastStatusUpdate = currentTime
        end
        return
    end

    local position = findValidPlacementPosition()
    if not position then
        if currentTime - (placementSettings.lastPositionWarning or 0) > 5 then
            warn("Could not find valid placement position")
            placementSettings.lastPositionWarning = currentTime
        end
        return
    end

    if placeUnit(unitToPlace, position) then
        placementSettings.lastPlacement = currentTime
    end
end

local function autoplayUpgradeLoop()
    if not autoplayActive then return end
    
    local currentTime = tick()
    
    -- Check if enough time has passed since last upgrade
    if currentTime - placementSettings.lastUpgrade < 0.1 then
        return
    end
    
    -- Get units that can be upgraded
    local unitsToUpgrade = getUnitsToUpgrade()
    if #unitsToUpgrade == 0 then
        return -- Nothing to upgrade
    end
    
    -- Upgrade the highest priority unit
    local unitToUpgrade = unitsToUpgrade[1]
    if upgradeUnit(unitToUpgrade) then
        placementSettings.lastUpgrade = currentTime
         print("DEBUG - Upgrade successful!")
    end
end
local function startAutoplay()
    if autoplayActive then
        print("Autoplay is already running!")
        return
    end
    
    -- Check if required dependencies are available
    if not getAutoplayZone() then
        warn("Autoplay zone not found! Enable the green rectangle first.")
        return
    end
    
    autoplayActive = true
    
    -- Connect the loops
    placementConnection = RunService.Heartbeat:Connect(autoplayPlacementLoop)
    upgradeConnection = RunService.Heartbeat:Connect(autoplayUpgradeLoop)
    
    print("ü§ñ AUTOPLAY STARTED!")
    print("Placing units in priority order with spawn caps:")
    local spawnCaps = getAllSpawnCaps()  -- Removed _G.TowerSliders.
    for i = 1, 6 do
        local towerSlot = "tower" .. i
        print(string.format("  %s: %d units max", towerSlot, spawnCaps[towerSlot]))
    end
end

local function stopAutoplay()
    if not autoplayActive then
        print("Autoplay is not running!")
        return
    end
    
    autoplayActive = false
    
    -- Disconnect loops
    if placementConnection then
        placementConnection:Disconnect()
        placementConnection = nil
    end
    
    if upgradeConnection then
        upgradeConnection:Disconnect()
        upgradeConnection = nil
    end
    
    print("üõë AUTOPLAY STOPPED!")
end

local function getAutoplayStatus()
    cleanupInvalidUnits()
    
    local current = getCurrentUnitCount()
    local max = getMaxUnitCount()
    local placedCounts = getPlacedUnitCountsBySlot()
    local spawnCaps = getAllSpawnCaps()  -- Removed _G.TowerSliders.
    
    local status = {
        active = autoplayActive,
        currentUnits = current,
        maxUnits = max,
        placedUnits = #placedUnits,
        playerCash = getPlayerCash(),  -- Removed _G.UnitSystem and
        placedCounts = placedCounts
    }
    
    print("=== AUTOPLAY STATUS ===")
    print("Active:", status.active)
    print("Player Cash:", status.playerCash)
    print(string.format("Total Units: %d/%d (Game Limit)", current, max))
    print("Tracked Units:", #placedUnits)
    print("Units by Tower Slot:")
    for towerSlot, count in pairs(placedCounts) do
        local cap = spawnCaps[towerSlot] or 0
        print(string.format("  %s: %d/%d", towerSlot, count, cap))
    end
    print("=======================")
    
    return status
end

-- Clear placed units data (for reset)
local function clearPlacedUnits()
    placedUnits = {}
    print("Cleared placed units data")
end

local function getSpawnCap(towerSlot)
    return spawnCaps[towerSlot] or 0
end

local function updateAutoplaySettings()
    -- This will be called whenever a spawn cap changes
    -- You can add logic here to update your autoplay system
    print("Autoplay settings updated:")
    for tower, cap in pairs(spawnCaps) do
        print(string.format("  %s: %d", tower, cap))
    end
end

local function getTotalUpgradeCost(unitData)
    if not unitData.upgrades then
        return 0
    end
    
    local totalCost = 0
    for _, upgrade in pairs(unitData.upgrades) do
        totalCost = totalCost + (upgrade.Cost or 0)
    end
    
    return totalCost
end

local function getUpgradeCost(unitName, upgradeLevel)
    print("DEBUG - getUpgradeCost for:", unitName, "level:", upgradeLevel)
    
    local config = getUnitConfig(unitName)
    if not config or not config.UnitConfig or not config.UnitConfig.Upgrades then
        print("DEBUG - No config or upgrades found for:", unitName)
        return 0
    end
    
    local upgrades = config.UnitConfig.Upgrades
    print("DEBUG - Total upgrades available:", #upgrades)
    
    if upgradeLevel >= 1 and upgradeLevel <= #upgrades then
        local cost = upgrades[upgradeLevel].Cost or 0
        print("DEBUG - Upgrade cost for level", upgradeLevel, "is:", cost)
        return cost
    end
    
    print("DEBUG - Invalid upgrade level:", upgradeLevel)
    return 0
end

local function getCostToUpgrade(unitData, fromLevel, toLevel)
    if not unitData.upgrades or fromLevel >= toLevel then
        return 0
    end
    
    local totalCost = 0
    for level = fromLevel + 1, math.min(toLevel, #unitData.upgrades) do
        totalCost = totalCost + getUpgradeCost(unitData, level)
    end
    
    return totalCost
end



local function canAffordUpgrade(unitData, upgradeLevel)
    local playerCash = getPlayerCash()
    local upgradeCost = getUpgradeCost(unitData, upgradeLevel)
    return playerCash >= upgradeCost
end



local function printUnitAnalysis()
    local units = getAvailableUnits()
    local playerCash = getPlayerCash()
    
    print("=== UNIT ANALYSIS ===")
    print("Player Cash:", playerCash)
    print("Available Units:", #units)
    print("")
    
    for _, unit in pairs(units) do
        local affordable = canAffordUnit(unit) and "‚úì" or "‚úó"
        local totalUpgradeCost = getTotalUpgradeCost(unit)
        
        -- Safe calculation of value score
        local damage = unit.damage or 0
        local apm = unit.apm or 0
        local cost = unit.cost or 1
        local valueScore = 0
        if cost > 0 and damage > 0 and apm > 0 then
            valueScore = (damage * apm) / cost
        end
        
        print(string.format("%s %s (%s)", affordable, unit.displayName or unit.name, unit.rarity or "unknown"))
        print(string.format("  Cost: %d | Range: %d | Damage: %d | APM: %d", 
            cost, unit.range or 0, damage, apm))
        print(string.format("  Value Score: %.2f | Upgrade Cost: %d | Max Level: %d", 
            valueScore, totalUpgradeCost, #unit.upgrades))
        
        -- Show upgrade costs
        if #unit.upgrades > 0 then
            local upgradeCosts = {}
            for i, upgrade in pairs(unit.upgrades) do
                table.insert(upgradeCosts, tostring(upgrade.Cost))
            end
            print("  Upgrade Costs:", table.concat(upgradeCosts, " ‚Üí "))
        end
        print("")
    end
    
    local bestUnits = getBestAffordableUnits()
    if #bestUnits > 0 then
        print("=== BEST AFFORDABLE UNITS ===")
        for i, unit in pairs(bestUnits) do
            if i <= 3 then -- Show top 3
                print(string.format("%d. %s (Score: %.2f, Cost: %d)", 
                    i, unit.displayName, unit.valueScore, unit.cost))
            end
        end
    end
    print("========================")
end

local function getEnemySpawnPoint()
    local success, spawn = pcall(function()
        return workspace.Map.Path.Start
    end)
    if success and spawn then
        return spawn
    else
        warn("Enemy spawn point not found at workspace.Map.Path.Start")
        return nil
    end
end

local function findGroundPosition(startPosition)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {rectangle} -- Don't hit our own rectangle
    
    -- Cast ray downward
    local rayDirection = Vector3.new(0, -config.raycastDistance, 0)
    local raycastResult = workspace:Raycast(startPosition, rayDirection, raycastParams)
    
    if raycastResult then
        -- Position the rectangle slightly above the ground
        return raycastResult.Position + Vector3.new(0, config.height/2, 0)
    else
        -- Fallback: use original position if no ground found
        warn("No ground found, using spawn position")
        return startPosition
    end
end

local function createRectangle()
    if rectangle then
        rectangle:Destroy()
    end
    
    local spawnPoint = getEnemySpawnPoint()
    if not spawnPoint then
        return nil
    end
    
    -- Calculate position with offset
    local targetPosition = spawnPoint.Position + config.offsetFromSpawn
    
    -- Raycast to find ground
    local groundPosition = findGroundPosition(targetPosition)
    
    -- Create the part
    rectangle = Instance.new("Part")
    rectangle.Name = "AutoplayZone"
    rectangle.Size = Vector3.new(config.width, config.height, config.length)
    rectangle.Material = config.material
    rectangle.BrickColor = BrickColor.new("Bright green")
    rectangle.Color = config.color
    rectangle.Transparency = config.transparency
    rectangle.CanCollide = config.canCollide
    rectangle.Anchored = true
    rectangle.Shape = Enum.PartType.Block
    
    -- Position it on the ground
    rectangle.Position = groundPosition
    
    -- Add selection box for better visibility
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Adornee = rectangle
    selectionBox.Color3 = Color3.fromRGB(0, 200, 0)
    selectionBox.LineThickness = 0.15
    selectionBox.Transparency = 0.2
    selectionBox.Parent = rectangle
    
    -- Add a subtle glow effect
    local pointLight = Instance.new("PointLight")
    pointLight.Color = config.color
    pointLight.Brightness = 0.5
    pointLight.Range = config.width
    pointLight.Parent = rectangle
    
    rectangle.Parent = workspace
    
    return rectangle
end

local function toggleRectangle()
    if rectangleEnabled then
        print("3D Autoplay zone enabled")
        rectangle = createRectangle()
        if rectangle then
            print("Rectangle created at position:", rectangle.Position)
            print("Rectangle size:", rectangle.Size)
        end
    else
        print("3D Autoplay zone disabled")
        if rectangle then
            rectangle:Destroy()
            rectangle = nil
        end
    end
end

local function setSize(width, length)
    config.width = width
    config.length = length
    if rectangleEnabled and rectangle then
        rectangle.Size = Vector3.new(config.width, config.height, config.length)
        -- Update light range too
        local light = rectangle:FindFirstChild("PointLight")
        if light then
            light.Range = config.width
        end
    end
    print("Rectangle size set to:", width, "x", length)
end

local function setHeight(height)
    config.height = height
    if rectangleEnabled and rectangle then
        rectangle.Size = Vector3.new(config.width, config.height, config.length)
        -- Reposition to stay on ground
        local spawnPoint = getEnemySpawnPoint()
        if spawnPoint then
            local targetPosition = spawnPoint.Position + config.offsetFromSpawn
            local groundPosition = findGroundPosition(targetPosition)
            rectangle.Position = groundPosition
        end
    end
    print("Rectangle height set to:", height)
end

local function setOffset(x, y, z)
    config.offsetFromSpawn = Vector3.new(x, y, z)
    if rectangleEnabled and rectangle then
        local spawnPoint = getEnemySpawnPoint()
        if spawnPoint then
            local targetPosition = spawnPoint.Position + config.offsetFromSpawn
            local groundPosition = findGroundPosition(targetPosition)
            rectangle.Position = groundPosition
        end
    end
    print("Offset set to:", x, ",", y, ",", z)
end

local function setTransparency(transparency)
    config.transparency = math.clamp(transparency, 0, 1)
    if rectangleEnabled and rectangle then
        rectangle.Transparency = config.transparency
    end
    print("Transparency set to:", config.transparency)
end

local function setColor(r, g, b)
    config.color = Color3.fromRGB(r, g, b)
    if rectangleEnabled and rectangle then
        rectangle.Color = config.color
        local light = rectangle:FindFirstChild("PointLight")
        if light then
            light.Color = config.color
        end
    end
    print("Color set to RGB:", r, g, b)
end

local function setMaterial(material)
    config.material = material
    if rectangleEnabled and rectangle then
        rectangle.Material = config.material
    end
    print("Material set to:", material.Name)
end

local function repositionOnGround()
    if rectangleEnabled and rectangle then
        local spawnPoint = getEnemySpawnPoint()
        if spawnPoint then
            local targetPosition = spawnPoint.Position + config.offsetFromSpawn
            local groundPosition = findGroundPosition(targetPosition)
            rectangle.Position = groundPosition
            print("Rectangle repositioned to:", groundPosition)
        end
    else
        print("No rectangle to reposition")
    end
end

local function setToggleKey(keyCode)
    config.toggleKey = keyCode
    print("Toggle key set to:", keyCode.Name)
end

task.spawn(function()
    while true do
        wait(15)
        if autoplayActive then
            cleanupInvalidUnits()
        end
    end
end)

local function sendWebhook(messageType, rewards, clearTime)
    if not ValidWebhook then return end

    local data
    if messageType == "test" then
        data = {
            username = "LixHub Bot",
            content = "",
            embeds = {{
                title = "üì¢ LixHub Notification",
                description = "üß™ Test webhook sent successfully",
                color = 0x5865F2,
                footer = { text = "LixHub Auto Logger" },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
    elseif messageType == "stage" then
        local RewardsUI = "Seeds: "..LocalPlayer:WaitForChild("leaderstats").Seeds.Value
        local stageName = game.workspace:GetAttribute("MapId") or "Unknown Stage"
        local gameMode = LocalPlayer:GetAttribute("UnitsPlaced")
        local isWin = game.workspace.Map.BaseHP:GetAttribute("HP") > 0
        local resultText = isWin and "Win" or "Lose"
        local stageResult = stageName .. " - Units Placed: " .. gameMode .. " - " .. resultText
        local timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        data = {
            username = "LixHub Bot",
            content = nil,
            embeds = {{
                title = "üéØ Stage Finished!",
                description = stageResult,
                color = (isWin and 0x57F287 or 0xED4245),
                fields = {
                    { name = "üë§ Player", value = "||" .. LocalPlayer.Name .. "||", inline = true },
                    { name = isWin and "‚úÖ Won in:" or "‚ùå Lost after:", value = clearTime, inline = true },
                    { name = "üèÜ Rewards", value = RewardsUI, inline = false },
                    { name = "üìà Script Version", value = "v0.0.1", inline = true },
                },
                footer = { text = "discord.gg/lixhub" },
                timestamp = timestamp
            }}
        }

        local filteredFields = {}
        for _, field in ipairs(data.embeds[1].fields) do if field then table.insert(filteredFields, field) end end
        data.embeds[1].fields = filteredFields
    else
        return
    end

    local payload = HttpService:JSONEncode(data)
    local requestFunc = (syn and syn.request) or (http and http.request) or request

    if requestFunc then
        local success, result = pcall(function()
           -- notify("Webhook", "Sending webhook...")
            return requestFunc({
                Url = ValidWebhook,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = payload
            })
        end)

        if success then
        else
            warn("Webhook failed to send: " .. tostring(result))
        end
    else
        warn("No compatible HTTP request method found.")
    end
end

local function ensureMacroFolders()
    if not isfolder("LixHub") then
        makefolder("LixHub")
    end
    if not isfolder("LixHub/Macros") then
        makefolder("LixHub/Macros")
    end
    if not isfolder("LixHub/Macros/GTD") then
        makefolder("LixHub/Macros/GTD")
    end
end

local function serializeVector3(v)
    return { x = v.X, y = v.Y, z = v.Z }
end

local function serializeCFrame(cf)
    local x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = cf:GetComponents()
    return {
        x = x, y = y, z = z,
        r00 = r00, r01 = r01, r02 = r02,
        r10 = r10, r11 = r11, r12 = r12,
        r20 = r20, r21 = r21, r22 = r22
    }
end


local function deserializeVector3(t)
    return Vector3.new(t.x, t.y, t.z)
end

local function deserializeCFrame(t)
    return CFrame.new(
        t.x, t.y, t.z,
        t.r00, t.r01, t.r02,
        t.r10, t.r11, t.r12,
        t.r20, t.r21, t.r22
    )
end


local function getMacroFilename(name)
    -- Handle case where name might be a table
    if type(name) == "table" then
        name = name[1] or ""
    end
    
    -- Ensure name is a string
    if type(name) ~= "string" or name == "" then
        warn("getMacroFilename: Invalid name provided:", name)
        return nil
    end
    
    return "LixHub/Macros/GTD/" .. name .. ".json"
end

local function saveMacroToFile(name)
    local data = macroManager[name]
    if not data then return end

    local serializedData = {}
    for _, action in ipairs(data) do
        local newAction = table.clone(action)
        if newAction.position then
            newAction.position = serializeVector3(newAction.position)
        end
        if newAction.cframe then
            newAction.cframe = serializeCFrame(newAction.cframe)
        end
        table.insert(serializedData, newAction)
    end

    local json = HttpService:JSONEncode(serializedData)
    writefile(getMacroFilename(name), json)
end

local function loadMacroFromFile(name)
    local filePath = getMacroFilename(name)
    if not isfile(filePath) then return end

        local json = readfile(filePath)
        local data = HttpService:JSONDecode(json)

        for _, action in ipairs(data) do
        if action.position then
            action.position = deserializeVector3(action.position)
        end
        if action.cframe then
            action.cframe = deserializeCFrame(action.cframe)
        end
    end
    macroManager[name] = data
    return data
end

local function deleteMacroFile(name)
    if isfile(getMacroFilename(name)) then
        delfile(getMacroFilename(name))
    end
    macroManager[name] = nil
end

local function loadAllMacros()
    macroManager = {}
    for _, file in ipairs(listfiles("LixHub/Macros/GTD/")) do
        if file:match("%.json$") then
            local name = file:match("([^/\\]+)%.json$")
            loadMacroFromFile(name)
        end
    end
end

local function waitForGameStart()
	Rayfield:Notify({
		Title = "Waiting for Game",
		Content = "Waiting for next game to start...",
		Duration = 2,
		Image = 4483362458
	})

	local prevTime = workspace:GetAttribute("GameStartTime")
	repeat 
		task.wait(0.1) 
	until workspace:GetAttribute("GameStartTime") and workspace:GetAttribute("GameStartTime") ~= prevTime

	return workspace:GetAttribute("GameStartTime")
end

local function waitForGameStartTiming()
	local prevTime = workspace:GetAttribute("GameStartTime")
	repeat 
		task.wait(0.1) 
	until workspace:GetAttribute("GameStartTime") and workspace:GetAttribute("GameStartTime") ~= prevTime

	return workspace:GetAttribute("GameStartTime")
end

task.spawn(function()
	while true do
		local newStartTime = waitForGameStartTiming()
		State.StageStartTime = tick()
		State.hasSentWebhook = false
		print("New game started at:", State.StageStartTime)
	end
end)

local function waitForUnitId(targetPos, timeout)
    local start = tick()
    repeat
        local id = FindUnitId(targetPos)
        if id then return id end
        task.wait(0.1)
    until tick() - start >= timeout
    return nil
end

_G.MacroCashSystem = {
    executeAction = executeActionWithCashCheck
}


local function playMacroLoop()
    isPlayingLoopRunning = true
    
    while isPlaybacking do
        -- Check if a game is already in progress
        local currentGameStartTime = workspace:GetAttribute("GameStartTime")
        local gameStartTime
        
        if currentGameStartTime then
            -- Game is already in progress, use current time as start
            gameStartTime = tick()
            print("üéÆ Game already in progress, starting macro immediately")
        else
            -- No game in progress, wait for one to start
            print("üé¨ Waiting for game to start...")
            gameStartTime = waitForGameStart()
            currentGameStartTime = workspace:GetAttribute("GameStartTime")
        end
        
        -- Double check that playback is still enabled after waiting
        if not isPlaybacking then
            print("üõë Playback disabled while waiting for game start")
            break
        end
        
        local actionIndex = 1  -- Always start from action 1 for each new game
        
        print(string.format("üé¨ Starting macro playback in '%s' mode", playbackMode))
        print(string.format("üìä Macro has %d total actions to execute", #macro))
        
        -- Reset wave tracking for new game
        currentWave = getCurrentWave()
        waveStartTime = tick()
        
        -- Reset placed units tracking for new game
        placedUnitsTracking = {}
        
        -- Store the game start time for this specific game
        local thisGameStartTime = currentGameStartTime
        
        while isPlaybacking and actionIndex <= #macro do
            -- Check if a new game has started (game restart detection)
            local newGameStartTime = workspace:GetAttribute("GameStartTime")
            if newGameStartTime and newGameStartTime ~= thisGameStartTime then
                print("üîÑ New game detected during playback, restarting macro...")
                break -- Break out of action loop to restart from beginning
            end
            
            -- Update wave tracking
            onWaveChanged()
            
            local currentTime = tick() - gameStartTime
            local currentWaveTime = tick() - waveStartTime
            local action = macro[actionIndex]
            
            -- Check if we should execute this action based on the selected mode
            local shouldExecute = shouldExecuteAction(action, currentTime, currentWave, currentWaveTime)
            
            if shouldExecute then
                print(string.format("üéØ Executing action %d/%d: %s (Mode: %s)", 
                    actionIndex, #macro, action.action, playbackMode))
                
                -- Try MacroCashSystem first if it exists
                local result = nil
                if _G.MacroCashSystem and _G.MacroCashSystem.executeAction then
                    result = _G.MacroCashSystem.executeAction(action)
                    print(string.format("üí∞ MacroCashSystem result: %s", tostring(result)))
                end
                
                -- Handle MacroCashSystem results
                if result == "wait" then
                    -- Don't advance to next action, try again next loop
                    print("‚è≥ MacroCashSystem returned 'wait' - retrying action next loop")
                    task.wait(1) -- Wait 1 second before retrying
                    -- Don't increment actionIndex - will retry this action
                    
                elseif result == "skip" then
                    print("‚è≠Ô∏è MacroCashSystem returned 'skip' - moving to next action")
                    actionIndex = actionIndex + 1
                    
                elseif result == "success" then
                    print("‚úÖ MacroCashSystem returned 'success' - moving to next action")
                    actionIndex = actionIndex + 1
                    
                elseif result == "failed" then
                    print("‚ùå MacroCashSystem returned 'failed' - moving to next action")
                    actionIndex = actionIndex + 1
                    
                else
                    -- MacroCashSystem didn't handle it or returned nil/unknown result
                    -- Fall back to original logic
                    print(string.format("üîÑ Falling back to original logic for %s (result was: %s)", 
                        action.action, tostring(result)))
                    
                    local actionHandled = false
                    local actionSuccess = false
                    
                    if action.action == "PlaceUnit" then
                        local success = tryPlaceUnit(action.unitName, {
                            Valid = action.valid,
                            Rotation = action.rotation,
                            CF = action.cframe,
                            Position = action.position
                        }, 5)
                        
                        if success then
                            print(string.format("‚úÖ Successfully placed unit: %s", action.unitName))
                            actionSuccess = true
                        else
                            print(string.format("‚è≠Ô∏è Failed to place unit: %s", action.unitName))
                        end
                        actionHandled = true
                        
                    elseif action.action == "UpgradeUnit" then
                        local id = FindUnitId(action.position)
                        if id then
                            local success, err = pcall(function()
                                game.ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(id)
                            end)
                            if success then
                                print("‚¨ÜÔ∏è Upgraded unit:", id)
                                actionSuccess = true
                            else
                                warn("Failed to upgrade unit:", id, err)
                            end
                        else
                            warn("‚ö†Ô∏è Could not find unit to upgrade at position:", action.position)
                        end
                        actionHandled = true
                        
                    elseif action.action == "SellUnit" then
                        local id = FindUnitId(action.position)
                        if id then
                            local success, err = pcall(function()
                                game.ReplicatedStorage.RemoteFunctions.SellUnit:InvokeServer(id)
                            end)
                            if success then
                                print("üí∞ Sold unit:", id)
                                actionSuccess = true
                            else
                                warn("Failed to sell unit:", id, err)
                            end
                        else
                            warn("‚ö†Ô∏è Could not find unit to sell at position:", action.position)
                        end
                        actionHandled = true
                        
                    elseif action.action == "SkipWave" then
                        local success, err = pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SkipWave"):InvokeServer("y")
                        end)
                        if success then
                            print("‚è© Skipped wave")
                            actionSuccess = true
                        else
                            warn("Failed to skip wave:", err)
                        end
                        actionHandled = true
                    end
                    
                    -- Always advance if we handled it with original logic
                    if actionHandled then
                        actionIndex = actionIndex + 1
                    else
                        print(string.format("‚ö†Ô∏è Unknown action type: %s - skipping", action.action))
                        actionIndex = actionIndex + 1
                    end
                end
            else
                -- Don't increment actionIndex when conditions aren't met
                -- Just wait and check again in the next loop iteration
                --print(string.format("‚è∞ Waiting for action %d - timing/wave conditions not met (current: %.2fs, required: %.2fs)", actionIndex, currentTime, action.time or 0))
                -- Don't increment actionIndex here - we want to retry this action
            end
            
            task.wait(0.1) -- Small delay to prevent excessive CPU usage
        end
        
        if actionIndex > #macro then
            print("üéØ Macro completed all actions, waiting for next game...")
        else
            print("üîÑ Macro interrupted (game restart or playback disabled)")
        end
        
        -- Only wait for new game if we completed the macro and playback is still enabled
        if actionIndex > #macro and isPlaybacking then
            print("üé¨ Waiting for next game to start...")
            waitForGameStart()
        end
    end
    
    isPlayingLoopRunning = false
    print("üõë Macro playback loop ended")
end

local function GetUnitPositionFromId(id)
    local entities = workspace:WaitForChild("Map"):WaitForChild("Entities")

    for _, model in ipairs(entities:GetChildren()) do
        if model:GetAttribute("ID") == id and model:FindFirstChild("Anchor") then
            return model.WorldPivot.Position
        end
    end

    warn("GetUnitPositionFromId: No position found for ID", id)
    return nil
end

mt.__namecall = newcclosure(function(self, ...)
    local args = { ... }
    local method = getnamecallmethod()
    if not checkcaller() then
        task.spawn(function()
            if isRecording and method == "InvokeServer" and self.Name == "PlaceUnit" then
                local timestamp = tick() 
                local currentWaveNum = getCurrentWave()
                
                table.insert(macro, {
                    action = "PlaceUnit",
                    unitName = args[1],
                    position = args[2].Position,
                    rotation = args[2].Rotation,
                    cframe = args[2].CF,
                    valid = args[2].Valid,
                    time = timestamp - recordingStartTime,
                    wave = currentWaveNum -- ADD WAVE DATA
                })

            elseif isRecording and method == "InvokeServer" and self.Name == "UpgradeUnit" then
                local timestamp = tick() 
                local currentWaveNum = getCurrentWave()
                local id = args[1]
                local pos = GetUnitPositionFromId(id)
                
                table.insert(macro, {
                    action = "UpgradeUnit", 
                    position = pos,
                    time = timestamp - recordingStartTime,
                    wave = currentWaveNum -- ADD WAVE DATA
                })

            elseif isRecording and method == "InvokeServer" and self.Name == "SellUnit" then
                local timestamp = tick() 
                local currentWaveNum = getCurrentWave()
                local id = args[1]
                local pos = GetUnitPositionFromId(id)
                
                table.insert(macro, {
                    action = "SellUnit", 
                    position = pos,
                    time = timestamp - recordingStartTime,
                    wave = currentWaveNum -- ADD WAVE DATA
                })
                
            elseif isRecording and method == "InvokeServer" and self.Name == "SkipWave" then
                local timestamp = tick() 
                local currentWaveNum = getCurrentWave()
                
                table.insert(macro, {
                    action = "SkipWave",
                    time = timestamp - recordingStartTime,
                    wave = currentWaveNum -- ADD WAVE DATA
                })
            end
        end)
    end
    return oldNamecall(self, ...) -- Keep your original variable name
end)
setreadonly(mt, true)

local Window = Rayfield:CreateWindow({
   Name = "LixHub - Garden Tower Defense",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Loading for Garden Tower Defense",
   LoadingSubtitle = "v0.0.1",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = {
    TextColor = Color3.fromRGB(240, 240, 240),

    Background = Color3.fromRGB(25, 25, 25),
    Topbar = Color3.fromRGB(34, 34, 34),
    Shadow = Color3.fromRGB(20, 20, 20),

    NotificationBackground = Color3.fromRGB(20, 20, 20),
    NotificationActionsBackground = Color3.fromRGB(230, 230, 230),

    TabBackground = Color3.fromRGB(80, 80, 80),
    TabStroke = Color3.fromRGB(85, 85, 85),
    TabBackgroundSelected = Color3.fromRGB(210, 210, 210),
    TabTextColor = Color3.fromRGB(240, 240, 240),
    SelectedTabTextColor = Color3.fromRGB(50, 50, 50),

    ElementBackground = Color3.fromRGB(35, 35, 35),
    ElementBackgroundHover = Color3.fromRGB(40, 40, 40),
    SecondaryElementBackground = Color3.fromRGB(25, 25, 25),
    ElementStroke = Color3.fromRGB(50, 50, 50),
    SecondaryElementStroke = Color3.fromRGB(40, 40, 40),
            
    SliderBackground = Color3.fromRGB(50, 138, 220),
    SliderProgress = Color3.fromRGB(50, 138, 220),
    SliderStroke = Color3.fromRGB(58, 163, 255),

    ToggleBackground = Color3.fromRGB(30, 30, 30),
    ToggleEnabled = Color3.fromRGB(0, 146, 214),
    ToggleDisabled = Color3.fromRGB(100, 100, 100),
    ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
    ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
    ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
    ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

    DropdownSelected = Color3.fromRGB(102, 102, 102),
    DropdownUnselected = Color3.fromRGB(30, 30, 30),

    InputBackground = Color3.fromRGB(30, 30, 30),
    InputStroke = Color3.fromRGB(65, 65, 65),
    PlaceholderColor = Color3.fromRGB(178, 178, 178)
}, -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "K", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = "LixHub", -- Create a custom folder for your hub/game
      FileName = "Lixhub_GTD"
   },

   Discord = {
      Enabled = true, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "cYKnXE2Nf8", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "LixHub - GTD - Free",
      Subtitle = "LixHub - Key System",
      Note = "Free key available in the discord https://discord.gg/cYKnXE2Nf8", -- Use this to tell the user how to get a key
      FileName = "LixHub_Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"0xLIXHUB"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local JoinerTab = Window:CreateTab("Joiner", "plug-zap")
local MacroTab = Window:CreateTab("Macro", "tv")
local GameTab = Window:CreateTab("Game", "gamepad-2")
local AutoplayTab = Window:CreateTab("Autoplay", "joystick")
local WebhookTab = Window:CreateTab("Webhook", "bluetooth")

   Toggle = JoinerTab:CreateToggle({
    Name = "Enable Auto Join",
    CurrentValue = false,
    Flag = "EnableAutoJoin",
    Callback = function(Value)
        State.AutoJoinEnabled = Value
    end,
    })

local JoinerSelector = JoinerTab:CreateDropdown({
   Name = "Select Stage To Join",
   Options = {"Garden","Enchanted Jungle","Tropical Island","Toxic Facility"},
   CurrentOption = {},
   MultipleOptions = false,
   Flag = "StageJoinSelector",
Callback = function(selected)

   end,
})

   Toggle = JoinerTab:CreateToggle({
    Name = "Enable Auto Join (Endless)",
    CurrentValue = false,
    Flag = "EnableAutoJoinEndless",
    Callback = function(Value)
        State.AutoJoinEndlessEnabled = Value
    end,
    })

local JoinerSelector = JoinerTab:CreateDropdown({
   Name = "Select Stage To Join (Endless)",
   Options = {"Garden","Enchanted Jungle","Tropical Island","Toxic Facility"},
   CurrentOption = {},
   MultipleOptions = false,
   Flag = "StageJoinSelectorEndless",
Callback = function(selected)

   end,
})


local MacroDropdown = MacroTab:CreateDropdown({
   Name = "Select Macro",
   Options = {},
   CurrentOption = currentMacroName,
   MultipleOptions = false,
   Flag = "MacroDropdown",
Callback = function(selected)
  local selectedName

if type(selected) == "table" then
    selectedName = selected[1]
else
    selectedName = selected
end

print("User selected macro:", selectedName)
currentMacroName = selectedName
if selectedName and macroManager[selectedName] then
    --currentMacroName = selectedName
    macro = macroManager[selectedName]
     Rayfield:Notify({
            Title = "Macro Selected",
            Content = "Selected macro '" .. selectedName .. "' with " .. #macro .. " actions.",
            Duration = 3
        })
else
    print("Invalid selection or macro doesn't exist:", selectedName)
end
   end,
})

local function refreshMacroDropdown()
    local options = {}

    for name in pairs(macroManager) do
        table.insert(options, name)
    end

    table.sort(options)

    -- Handle case where currentMacroName might be a table
    if type(currentMacroName) == "table" then
        currentMacroName = currentMacroName[1] or ""
    end

    -- Only set currentMacroName to first option if it's completely empty/nil
    -- Don't override if it exists but isn't in macroManager (it might be loading from config)  
    if not currentMacroName or currentMacroName == "" then
        currentMacroName = options[1]
    end

    -- Only update macro if currentMacroName exists in macroManager
    if currentMacroName and macroManager[currentMacroName] then
        macro = macroManager[currentMacroName]
    end

    MacroDropdown:Refresh(options, currentMacroName)

    for i, opt in ipairs(options) do
        print("Option " .. i .. " = " .. tostring(opt) .. " (" .. typeof(opt) .. ")")
    end

    print("Refreshed dropdown with:", table.concat(options, ", "))
    print("Current macro is:", currentMacroName, "Type:", type(currentMacroName))
end

ensureMacroFolders()
loadAllMacros()

local pendingMacroName = ""

local MacroInput = MacroTab:CreateInput({
   Name = "Input Macro Name",
   CurrentValue = "",
   PlaceholderText = "Enter macro name...",
   RemoveTextAfterFocusLost = false,
   Flag = "MacroInput",
   Callback = function(text)
	pendingMacroName = text
   end,
})

local CreateMacroButton = MacroTab:CreateButton({
   Name = "Create Empty Macro",
   Callback = function()
       local name = pendingMacroName
    if not name or name == "" then
        Rayfield:Notify({
            Title = "Error",
            Content = "Please enter a valid macro name.",
            Duration = 3
        })
        return
    end
    if macroManager[name] then
        Rayfield:Notify({
            Title = "Error",
            Content = "Macro '" .. name .. "' already exists.",
            Duration = 3
        })
        return
    end

    macroManager[name] = {}

    saveMacroToFile(name)
    refreshMacroDropdown()
    Rayfield:Notify({
        Title = "Success",
        Content = "Created macro '" .. name .. "'.",
        Duration = 3
    })
   end,
})

local RefreshMacroListButton = MacroTab:CreateButton({
   Name = "Refresh Macro List",
   Callback = function()
    loadAllMacros()
    refreshMacroDropdown()
    Rayfield:Notify({
        Title = "Success",
        Content = "Macro list refreshed.",
        Duration = 3
    })
   end,
})

local DeleteSelectedMacroButton = MacroTab:CreateButton({
   Name = "Delete Selected Macro",
   Callback = function()
         if not currentMacroName or currentMacroName == "" then
        Rayfield:Notify({
            Title = "Error",
            Content = "No macro selected.",
            Duration = 3
        })
        return
    end

    deleteMacroFile(currentMacroName)
    Rayfield:Notify({
        Title = "Deleted",
        Content = "Deleted macro '" .. currentMacroName .. "'.",
        Duration = 3
    })

    macroManager[currentMacroName] = nil
    macro = {}
    refreshMacroDropdown()
   end,
})

RecordToggle = MacroTab:CreateToggle({
	Name = "Record",
	CurrentValue = false,
	Flag = "RecordMacro",
	Callback = function(Value)
		isRecording = Value

		if Value and not isRecordingLoopRunning then
			Rayfield:Notify({
				Title = "Macro Recording",
				Content = "Waiting for game to start...",
				Duration = 4
			})

			recordingThread = task.spawn(function()
				waitForGameStart()
				if isRecording then
					isRecordingLoopRunning = true
					table.clear(macro)
					recordingStartTime = tick()

					Rayfield:Notify({
						Title = "Recording Started",
						Content = "Macro recording is now active.",
						Duration = 4
					})
				end
			end)

		elseif not Value then
			if isRecordingLoopRunning then
				Rayfield:Notify({
					Title = "Recording Stopped",
					Content = "Recording manually stopped.",
					Duration = 3
				})
			end
			isRecordingLoopRunning = false

            if currentMacroName then
            macroManager[currentMacroName] = macro
             ensureMacroFolders()
            saveMacroToFile(currentMacroName)
            end
		end
	end
})



PlayToggle = MacroTab:CreateToggle({
	Name = "Playback",
	CurrentValue = false,
	Flag = "PlayBackMacro",
	Callback = function(Value)
		isPlaybacking = Value

		if Value and not isPlayingLoopRunning then
    Rayfield:Notify({
        Title = "Macro Playback",
        Content = "Waiting for game to start...",
        Duration = 4
    })

    playbackThread = task.spawn(function()
        waitForGameStart()
        if isPlaybacking then
            if currentMacroName then
                ensureMacroFolders()
                local loadedMacro = loadMacroFromFile(currentMacroName)
                if loadedMacro then
                    macro = loadedMacro
                else
                    Rayfield:Notify({
                        Title = "Playback Error",
                        Content = "Failed to load macro: " .. tostring(currentMacroName),
                        Duration = 5,
                    })
                    isPlaybacking = false
                    PlayToggle:Set(false)
                    return
                end
            else
                Rayfield:Notify({
                    Title = "Playback Error",
                    Content = "No macro selected for playback.",
                    Duration = 5,
                })
                isPlaybacking = false
                PlayToggle:Set(false)
                return
            end

            isPlayingLoopRunning = true

            Rayfield:Notify({
                Title = "Playback Started",
                Content = "Macro is now executing...",
                Duration = 4
            })

            playMacroLoop()

            isPlayingLoopRunning = false
        end
    end)
elseif not Value then
    Rayfield:Notify({
        Title = "Macro Playback",
        Content = "Playback disabled.",
        Duration = 3
    })
        end
	end,
})

local function setPlaybackMode(mode)
    if mode == "timing" or mode == "wave" or mode == "both" then
        playbackMode = mode
        print(string.format("üéÆ Playback mode set to: %s", mode))
    else
        warn("Invalid playback mode:", mode)
    end
end

local PlaybackModeDropdown = MacroTab:CreateDropdown({
    Name = "Playback Mode",
    Options = {"timing", "wave", "both"},
    CurrentOption = {"timing"},
    MultipleOptions = false,
    Flag = "PlaybackModeDropdown",
    Callback = function(selected)
        local mode = type(selected) == "table" and selected[1] or selected
        setPlaybackMode(mode)
    end,
})

local Toggle = GameTab:CreateToggle({
   Name = "Auto Retry",
   CurrentValue = false,
   Flag = "AutoRetryToggle",
   Callback = function(Value)
		State.AutoRetryEnabled = Value
        if Value then
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("RestartGame"):InvokeServer()
        end
   end,
})

task.spawn(function()
    while true do
    task.wait(2)
     if State.AutoRetryEnabled then
        if LocalPlayer.PlayerGui.GameGui.Screen.Middle:FindFirstChild("GameEnd").Visible == true then
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("RestartGame"):InvokeServer()
        end
    end
end
end)

    local Toggle = GameTab:CreateToggle({
    Name = "Auto 1x/2x/3x Speed",
    CurrentValue = false,
    Flag = "AutoSpeedToggle",
    Callback = function(Value)
        State.AutoSelectSpeed = Value
    end,
})

    local AutoSpeedDropdown = GameTab:CreateDropdown({
    Name = "Select Auto Speed Value",
    Options = {"1x","2x","3x"},
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "AutoSpeedSelector",
    Callback = function(Options)
       State.SelectedSpeedValue = Options
    end,
})

task.spawn(function()
    while true do
        if State.AutoSelectSpeed and State.SelectedSpeedValue then
            local raw = State.SelectedSpeedValue
            local value = type(raw) == "table" and raw[1] or raw
            local clean = tostring(value):gsub("[^%d]", "")
            local speedNum = tonumber(clean)
            if speedNum then
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("ChangeTickSpeed"):InvokeServer(speedNum)
            end
        end
        task.wait(1)
    end
end)

local Toggle = GameTab:CreateToggle({
   Name = "Auto Select Difficulty",
   CurrentValue = false,
   Flag = "AutoSelectDifficultyToggle",
   Callback = function(Value)
		State.AutoSelectDifficultyEnabled = Value
   end,
})

local Dropdown = GameTab:CreateDropdown({
   Name = "Select Difficulty",
   Options = {"easy","normal","hard","insane","impossible"},
   CurrentOption = {},
   MultipleOptions = false,
   Flag = "DifficultySelectorDropdown",
   Callback = function(Options)
		State.SelectedDifficultyValue = Options
   end,
})

task.spawn(function()
	while true do
		if State.AutoSelectDifficultyEnabled and State.SelectedDifficultyValue and LocalPlayer.PlayerGui.GameGui.Screen.Middle:FindFirstChild("DifficultyVote").Visible then
game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("PlaceDifficultyVote"):InvokeServer("dif_"..unpack(State.SelectedDifficultyValue))
		end
		task.wait(1)
	end
end)

local Toggle = GameTab:CreateToggle({
   Name = "Auto Skip Waves",
   CurrentValue = false,
   Flag = "AutoSkipWavesToggle",
   Callback = function(Value)
		State.AutoSkipWaves = Value
   end,
})

task.spawn(function()
    while true do
        if State.AutoSkipWaves then
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SkipWave"):InvokeServer("y")
        end
        task.wait(0.5)
    end
end)

local placingCooldown = false

local Toggle = AutoplayTab:CreateToggle({
    Name = "Autoplay",
    CurrentValue = false,
    Flag = "AutoplayToggle",
    Callback = function(Value)
        if Value then
            startAutoplay()
        end
    end,
})

local Toggle = AutoplayTab:CreateToggle({
	Name = "Show Placement Area",
	CurrentValue = false,
	Flag = "PlacementAreaToggle",
	Callback = function(Value)
        rectangleEnabled = Value
            toggleRectangle()
	end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Zone Width",
   Range = {1, 100},
   Increment = 1,
   Suffix = "studs",
   CurrentValue = 10,
   Flag = "ZoneWidthSlider",
   Callback = function(Value)
        config.width = Value
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Zone length",
   Range = {1, 100},
   Increment = 1,
   Suffix = "studs",
   CurrentValue = 10,
   Flag = "ZoneLengthSlider",
   Callback = function(Value)
        config.length = Value
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 1 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower1SpawnCap",
   Callback = function(Value)
      spawnCaps.tower1 = Value
      updateAutoplaySettings()
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 2 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower2SpawnCap",
   Callback = function(Value)
      spawnCaps.tower2 = Value
      updateAutoplaySettings()
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 3 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower3SpawnCap",
   Callback = function(Value)
      spawnCaps.tower3 = Value
      updateAutoplaySettings()
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 4 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower4SpawnCap",
   Callback = function(Value)
      spawnCaps.tower4 = Value
      updateAutoplaySettings()
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 5 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower5SpawnCap",
   Callback = function(Value)
      spawnCaps.tower5 = Value
      updateAutoplaySettings()
   end,
})

local Slider = AutoplayTab:CreateSlider({
   Name = "Tower 6 Spawn Cap",
   Range = {0, 20},
   Increment = 1,
   Suffix = "x",
   CurrentValue = 5,
   Flag = "Tower6SpawnCap",
   Callback = function(Value)
      spawnCaps.tower6 = Value
      updateAutoplaySettings()
   end,
})

local Label5 = WebhookTab:CreateLabel("Awaiting Webhook Input...", "cable")

Input = WebhookTab:CreateInput({
    Name = "Input Webhook",
    CurrentValue = "",
    PlaceholderText = "Input Webhook...",
    RemoveTextAfterFocusLost = false,
    Flag = "WebhookInput",
    Callback = function(Text)
        local trimmed = Text:match("^%s*(.-)%s*$")

        if trimmed == "" then
            ValidWebhook = nil
            Label5:Set("Awaiting Webhook Input...")
            return
        end

        local valid = trimmed:match("^https://discord%.com/api/webhooks/%d+/.+$")

        if valid then
            ValidWebhook = trimmed
            Label5:Set("‚úÖ Webhook URL set!")
        else
            ValidWebhook = nil
            Label5:Set("‚ùå Invalid Webhook URL. Ensure it's complete and starts with 'https://discord.com/api/webhooks/'")
        end
    end,
})

      TestWebhookButton = WebhookTab:CreateButton({
    Name = "Test webhook",
    Callback = function()
        if ValidWebhook then
            sendWebhook("test")
        end
    end,
    })

     Toggle = WebhookTab:CreateToggle({
    Name = "Send On Stage Finished",
    CurrentValue = false,
    Flag = "sendWebhookWhenStageCompleted",
    Callback = function(Value)
        State.SendStageCompletedWebhook = Value
    end,
    })

-- Modified ShowGameEnd event handler
ShowGameEnd.OnClientEvent:Connect(function()
    print("game ended")
    
    -- Handle recording
    if isRecording then
        isRecording = false
        isRecordingLoopRunning = false
        Rayfield:Notify({
            Title = "Recording Stopped",
            Content = "Game ended, recording has been automatically stopped and saved.",
            Duration = 3,
            Image = 0,
        })
        RecordToggle:Set(false)

        if currentMacroName then
            macroManager[currentMacroName] = macro
            saveMacroToFile(currentMacroName)
        end
    end
    
    -- Handle webhook
    if not State.hasSentWebhook then
        if State.SendStageCompletedWebhook then
            local clearTime = math.floor(tick() - State.StageStartTime)
            local minutes = math.floor(clearTime / 60)
            local seconds = clearTime % 60
            local formattedTime = string.format("%d:%02d", minutes, seconds)

            State.hasSentWebhook = true
            sendWebhook("stage", nil, formattedTime)

            task.delay(5, function()
                State.hasSentWebhook = false
            end)
        end
    end
    
    -- Handle autoplay
    if autoplayActive then
        clearPlacedUnits()
    end
    
    isPlayingLoopRunning = false
end)

Rayfield:LoadConfiguration()

task.delay(1, function()
    local savedMacroName = Rayfield.Flags["MacroDropdown"]
    
    -- Handle case where savedMacroName might be a table
    if type(savedMacroName) == "table" then
        savedMacroName = savedMacroName[1]
    end
    
    if savedMacroName and savedMacroName ~= "" and type(savedMacroName) == "string" then
        currentMacroName = savedMacroName
        
        -- Load the macro data from file when restoring from config
        local loadedMacro = loadMacroFromFile(currentMacroName)
        if loadedMacro then
            macro = loadedMacro
            macroManager[currentMacroName] = loadedMacro
            print("Successfully loaded saved macro:", currentMacroName, "with", #macro, "actions")
        else
            print("Failed to load saved macro:", currentMacroName)
            currentMacroName = nil
        end
    else
        print("No valid saved macro name found. Type:", type(savedMacroName), "Value:", tostring(savedMacroName))
    end
    
    refreshMacroDropdown()
end)
